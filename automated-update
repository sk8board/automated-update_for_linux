#!/usr/bin/python3

from pathlib import Path
import subprocess
import time
import os


def main():
	
	# notify and exit if not being run as root
	if os.geteuid() != 0:
		subprocess.call(['echo', '***root privileges are required***'])
		exit(0)
	
	global counter
	counter = 0
	while True:
		
		# 0 = internet connected
		if check_internet() == 0:
			
			# check if package manager apt-get is installed
			if Path('/usr/bin/apt-get').exists() == True:
										
				# 0 = update completed
				if process_apt_update() == 0 and process_apt_upgrade() == 0 and process_flatpak() == 0:
					process_fwupdmgr()
					subprocess.call(['echo', '***automated update complete***'])
					exit(0)
			
				# if update was not completed, retry after delay	
				else:
					retry_update()
			
			# check if package manager dnf is installed
			elif Path('/usr/bin/dnf').exists() == True:	
				
				# 0 = update completed
				if process_dnf() == 0 and process_flatpak() == 0:
					process_fwupdmgr()
					subprocess.call(['echo', '***automated update complete***'])
					exit(0)
			
				# if update was not completed, r, retry after delay	
				else:
					retry_update()

			# check if package manager pacman is installed
			elif Path('/usr/bin/pacman').exists() == True:	
				
				# 0 = update completed
				if process_pacman() == 0 and process_flatpak() == 0:
					process_fwupdmgr()
					subprocess.call(['echo', '***automated update complete***'])
					exit(0)
			
				# if update was not completed, retry after delay	
				else:
					retry_update()
			
			
		else:
			subprocess.call(['echo', '***not connected to internet, retry after delay***'])
			# retry internet connection after delay
			time.sleep(300)	
				

def check_internet():
	
	# check for a connection to internet, exit code 0 = connected
	if subprocess.call(['/usr/bin/ping', '-c', '1', 'www.google.com']) == 0:  				
		subprocess.call(['echo', '***connected to internet***'])
		return 0
		
	else:
		return 1


def retry_update():
	
	global counter
	if counter > 2:
		subprocess.call(['echo', '***service failed due to server error***'])
		exit(1)
	counter += 1
	subprocess.call(['echo', '***update was not completed, retry after delay***'])
	time.sleep(10)


def process_apt_update():
	
	# get exit code for 'apt-get update' to check if updates are available, 0 = no updates available
	subprocess.call(['echo', '***apt-get check available update***'])
	exit_code = subprocess.call(['/usr/bin/apt-get', 'update', '--assume-no'])	
	
	if exit_code == 0:
		subprocess.call(['echo', '***apt-get updates are not available at this time***'])
		return 0
			
	else:	
		# perform apt updates
		subprocess.call(['echo', '***apt-get update***'])
		subprocess.call(['/usr/bin/systemd-inhibit', '--why="Performing automatic updates"', '--who="Update Manager"', '--what=shutdown', '--mode=block', '/usr/bin/apt-get', 'update', '-y'])	# provide the exit code of apt-get update command
		subprocess.call(['echo', '***apt-get update has completed***'])
		
		# get exit code for 'apt-get update' to check if updates are available, 0 = no updates available
		subprocess.call(['echo', '***apt-get check available update***'])
		exit_code = subprocess.call(['/usr/bin/apt-get', 'update', '--assume-no'])	
		
		if exit_code == 0:
			subprocess.call(['echo', '***apt-get updates are not available at this time***'])
			return 0
			
		else:
			subprocess.call(['echo', '***apt-get update exit code != 0***'])
			return 1		


def process_apt_upgrade():
	
	if Path('/usr/bin/mintupdate-cli').exists() == True:
		
		return process_mint()
		
	else:
	
		# get exit code for 'apt-get dist-upgrade', check if upgrades are available, 0 = no updates available
		subprocess.call(['echo', '***apt-get check available dist-upgrade***'])
		exit_code = subprocess.call(['/usr/bin/apt-get', 'dist-upgrade', '--assume-no'])	
		
		if exit_code == 0:
			subprocess.call(['echo', '***apt-get dist-upgrades are not available at this time***'])
			return 0
			
		else:
			# remove unused apt apps
			subprocess.call(['echo', '***apt-get autoremove***'])
			subprocess.call(['apt-get', 'autoremove', '-y'])
			
			# perform apt upgrades
			subprocess.call(['echo', '***apt-get dist-upgrade***'])
			subprocess.call(['/usr/bin/systemd-inhibit', '--why="Performing automatic updates"', '--who="Update Manager"', '--what=shutdown', '--mode=block', '/usr/bin/apt-get', 'dist-upgrade', '-y'])	# provide the exit code of apt-get upgrade command
			subprocess.call(['echo', '***apt dist-upgrade has completed***'])
			
			# get exit code for 'apt-get dist-upgrade', check if upgrades are available, 0 = no updates available
			subprocess.call(['echo', '***apt-get check available dist-upgrade***'])
			exit_code = subprocess.call(['/usr/bin/apt-get', 'dist-upgrade', '--assume-no'])	
			
			if exit_code == 0:
				subprocess.call(['echo', '***apt-get dist-upgrades are not available at this time***'])
				return 0	
			
			else:
				subprocess.call(['echo', '***apt-get dist-upgrades exit code != 0***'])
				return 1


def process_dnf():
	
	# get exit code for 'dnf check-upgrade', check if upgrades are available, 0 = no updates available
	try:
		subprocess.call(['echo', '***dnf check available upgrades***'])
		exit_code = subprocess.call(['/usr/bin/dnf', 'check-upgrade'])	
	except Exception as e:
		print(e)
		exit_code = 0
	
	
	if exit_code == 0:
		subprocess.call(['echo', '***dnf upgrades are not available at this time***'])
		return 0
		
	else:
		# remove unused apt apps
		subprocess.call(['echo', '***dnf autoremove***'])
		subprocess.call(['dnf', 'autoremove', '-y'])
		
		# perform apt upgrades
		subprocess.call(['echo', '***dnf distro-sync***'])
		subprocess.call(['/usr/bin/systemd-inhibit', '--why="Performing automatic updates"', '--who="Update Manager"', '--what=shutdown', '--mode=block', '/usr/bin/dnf', 'distro-sync', '-y'])	# provide the exit code of apt-get upgrade command
		subprocess.call(['echo', '***dnf distro-sync has completed***'])
		
		# get exit code for 'dnf check-upgrade', check if upgrades are available, 0 = no updates available
		subprocess.call(['echo', '***dnf check available upgrades***'])
		exit_code = subprocess.call(['/usr/bin/dnf', 'check-upgrade'])
		
		if exit_code == 0:
			subprocess.call(['echo', '***dnf upgrades are not available at this time***'])
			return 0	
			
		else:
			subprocess.call(['echo', '***dnf check-upgrade exit code != 0***'])
			return 1	


def process_pacman():
	
	# work in progress
	return 0


def process_mint():
				
	# remove unused apt apps
	subprocess.call(['echo', '***apt-get autoremove***'])
	subprocess.call(['apt-get', 'autoremove', '-y'])
	
	# NEED TO FIX exit code always returns zero
	
	# Note: mintupdate-cli always provides an exit code of zero
	# upgrade Linux Mint using mintupdate-cli 
	subprocess.call(['echo', '***upgrade using mintupdate-cli***'])
	subprocess.call(['/usr/bin/mintupdate-cli', '-r', '-y', 'upgrade'])
	return 0


def process_cinnamon():
	
	# code taken from mintupdate-launcher
	subprocess.call(['echo', '***cinnamon updates***'])
	try:
		import cinnamon
		updater = cinnamon.UpdateManager()
		updater.refresh_all_caches()
		updates = updater.get_updates()
		if len(updates) > 0:
			msg = _("The following spices were automatically updated:")
			msg = msg + "\n"
			for update in updates:
				updater.upgrade(update)
				msg += "\n- %s (%s)" % (update.uuid, update.spice_type)
	
			if xapp.os.is_desktop_cinnamon():
				subprocess.call(["cinnamon-dbus-command", "RestartCinnamon", "0"])
				time.sleep(10) # Give cinnamon some time, otherwise it won't show our notification.
				notification_title = _("Cinnamon was restarted")
				notification = Notify.Notification.new(notification_title, msg, "cinnamon-symbolic")
				notification.set_urgency(2)
				notification.set_timeout(Notify.EXPIRES_NEVER)
				notification.show()
	except Exception as e:
		print("An error occurred while updating cinnamon spices: %s" % e)
	return 0


def process_flatpak():

	# check if cinnamon is installed
	if Path("/usr/bin/cinnamon").exists() == True:
		process_cinnamon()
	else:
		subprocess.call(['echo', '***cinnamon is not installed***'])


	if Path('/usr/bin/mintupdate-launcher').exists() == True:
		
		subprocess.call(['echo', '***mintupdate-launcher***'])
		subprocess.call(['mintupdate-launcher'])
		return 0

	else:

		# check if flatpak is installed
		if Path('/usr/bin/flatpak').exists() == False:
			subprocess.call(['echo', '***flatpak is not installed***'])
			return 0
		
		# get exit code for 'flatpak remote-ls --updates', check if updates are available, 0 = no updates available
		subprocess.call(['echo', '***flatpak remote-ls --updates***'])
		exit_code = subprocess.call(['/usr/bin/flatpak', 'remote-ls', '--updates'])	
		
		# NEED TO FIX exit code always returns zero
		
		if exit_code == 1:
			subprocess.call(['echo', '***flatpak updates are not available at this time***'])
			return 0
			
		else:
			# uninstall unused flatpaks
			subprocess.call(['echo', '***flatpak uninstall --unused***'])
			subprocess.call(['flatpak', 'uninstall', '--unused', '-y'])
			
			# perform flatpak updates
			subprocess.call(['echo', '***flatpak update***'])
			subprocess.call(['/usr/bin/systemd-inhibit', '--why="Performing automatic updates"', '--who="Update Manager"', '--what=shutdown', '--mode=block', '/usr/bin/flatpak', 'update', '-y'])	# provide the exit code of flatpak update command
			subprocess.call(['echo', '***flatpak update has completed***'])
			return 0
				

def process_fwupdmgr():
	
	# check if updates are available
	subprocess.call(['echo', '***fwupdmgr refresh --force***'])
	subprocess.call(['/usr/bin/fwupdmgr', 'refresh', '--force'])
	exit_code = subprocess.call(['/usr/bin/fwupdmgr', 'get-updates', '-y'])
	
	# perform update if update is available, 0 = update available, 2 = no update available
	if exit_code == 2:
		subprocess.call(['echo', '***firmware updates are not available at this time***'])
		return 0
	
	else:
		# send notification that a firmware update is available
		subprocess.call(["/usr/bin/notify-send-as-root", r"Firmware Update Needed", r"Run terminal command to update firmware: \n\n$ fwupdmgr upgrade"])
		subprocess.call(['echo', '***fwupdmgr update is available***'])
		return 0


if __name__ == '__main__':
    main()

